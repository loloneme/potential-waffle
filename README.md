# Инициализация проекта

-------
Развертывание проекта осуществляется с помощью Dockerfile, процесс описан в docker-compose.yml. Для запуска необходимо:

1. Склонировать репозиторий
```bash 
git clone https://github.com/loloneme/potential-waffle.git
```

2. Запустить проект с помощью Make

```bash
make docker-up
```

3. Для просмотра остальных доступных Make команд:

```bash 
make help
```

После выполнения всех шагов обращаться к приложению можно по адресу http://localhost:8080

# **Детали**

----
## code-gen
Для того, чтобы сделать запросы полностью подходящими и валидными для предоставленного API был использован инструмент https://github.com/oapi-codegen/oapi-codegen.

С его помощью я сгенерировала сервер, запросы и ответы, описанные в openapi, и типы. 
Однако для использования **echo** и **code-gen** необходимо было внедрить adapter, 
который вызывает соответствующие echo-хэндлеры.

Такой подход избавил меня от необходимости вручную прописывать и валидировать модели запросов и ответов, а также все эндопинты приложения.
Валидация запрсоов происходит с помощью middleware OpenAPIValidation 

## Ошибки
При написании ручек я столкнулась с тем, что прописывание ошибок для каждого хэндлера отдельно занимает очень много места и дублирует код.
Поэтому было решение вынести ошибки в отдельный пакет rpc_errors, что было непросто сделать ввиду сложной структруы ErrorResponse

## Миграции
Миграции осуществляются при помощи инструмента flyway, который позволяет прописывать разные версии изменения БД. Эти
версии применяются друг за другом к БД

## Интеграционные тесты
Трудности возникли на этапе написания интеграционных тестов. Я пробовала использовать **testcontainers** для Go, но 
появились сложности с миграциями, которые осуществляются в моем проекте с помощью flyway

Тогда было принято решение прописать отдельный docker-compose.test.yml для тестового окружения.
Каждый тест должен был проводиться в транзакции, которая в конце теста откатывается с помощью *t.Cleanup* и *Rollback*. 
Но! Так как сервисы (бизнес-логика) зачастую выполняются в транзакции, чтобы сделать операции атомарными 
(добавление pull-request, переназначение и т.д.), происходила вложенность транзакций. Этот вариант так же не подошел

Я решила просто обнулять БД в конце каждого теста, но и здесь возникла проблема - у тестов возникало состояние гонки, 
из-за чего они падали, не находя необходимых записей в таблицах, или наоборот, дублируя их. Поэтому тесты в итоге 
выполняются по очереди, а не параллельно

## Дополнительные задания
В качестве дополнительных заданий было выполнено:
### 1. Добавление линтера в проект

Конфигурация описана в .golangci.yml, запустить можно при помощи команды

```bash
make lint
```

### 2. Добавление эндпоинта статистики

Статистика доступно по эндпоинту **/statistics** и показывает, сколько PR ревьюят пользователи и сколько ревьюеров у PRов

### 3. Добавление массовой деактивации пользователей и переназначения открытых pull request`ов

Был добавлен новый метод с очень большой логикой. Для запроса нужно название команды и id пользователей, которых
нужно деактивировать

Именно поэтому в сервисе идет проверка того, что указанные пользователи действительно состоят в это команде.
Далее из них берутся только активные, чьи PR мы ищем. Находим список PR, их ревьюеров и деактивированных ревьюеров. 
После этого необходимо этих ревьюеров заменить - удалить запись в БД и добавить новую. Все это происходит в транзакции, 
чтобы в случае ошибки откатить изменения

### 4. Интеграционное и юнит-тестирование

Все репозитории и хэндлеры покрыты юнит-тестами. Для слоя бизнес-логики - сервисов используется интеграционное
тестирование с отдельно поднимаемым тестовым окружением


